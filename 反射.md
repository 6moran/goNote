**变量、interface{}、reflect.Value之间的转换：**

![image-20250925171854852](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250925171854852.png)

![image-20250925171941761](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250925171941761.png)

```go
func reflectTest01(b interface{}) {
    //通过反射获取到传入的变量的type,kind,值
    //1.先获取到reflect.Type
    rTyp := reflect.TypeOf(b)
    fmt.Println(rTyp)
    fmt.Printf("%T\n", rTyp)
    //获取到reflect.Value
    rVal := reflect.ValueOf(b)
    fmt.Println(rVal)
    fmt.Printf("%T\n", rVal)
    
    //将值转换回原来的变量
    //先转换为空接口
    iV := rVal.Interface()
    //类型断言
    num2 := iV.(int)
    fmt.Println(num2)
}
```

```go
//将值转换回原来的变量
//先转换为空接口
iV := rVal.Interface()
//这里是可以直接输出来值的，运行时可以输出
//这里编译器看做是打印一个接口，可以通过编译，运行时fmt会直接检测iV中存储的动态类型
fmt.Println(iV)
//这里因为编译器把他看作是接口，接口是没有Name属性的，因此不能通过编译
//这里不使用类型断言是不能打印出iV.Name的，会直接报错
//fmt.Println(iV.Name)
stu, ok := iV.(Student)
if ok {
    fmt.Println(stu.Name)
}
```

*注意：反射得来的类型不是原来的类型，是反射内部定义的数据类型。*

例如：你传了一个int类型，那么通过reflect.TypeOf得来的值虽然是int，但是该变量的类型是reflect.rtype，即reflect.TypeOf()的返回值是一个接口类型，而reflect.rtype类型实现了它。通过reflect.ValueOf得来的变量是reflect.Value类型。

reflect内部的Type接口：

![image-20250925173612265](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250925173612265.png)

**反射的注意事项和细节：**

1. kind的范畴是比type的范畴大的，例如对于一个结构体，kind的值是**struct**，type的值是**结构体名字**；对于一个基本类型，kind的值和type的值是相同的。
2. reflect.Value.Kind获取变量的类别，返回的是一个常量。
3. 使用反射的方式获取变量的值（并返回对应的类型），要求数据类型匹配，比如x是**int**，那么就应该使用**reflect.Value(x).int()**，而不能使用其他的，否则报panic。
4. 在函数中通过反射影响主函数的值：

   ```go
   func reflect01(b interface{}) {
       rVal := reflect.ValueOf(b)
       fmt.Printf("%T,%v\n", rVal, rVal.Kind())
       //Elem()会返回v持有的接口保管的值的Value封装，或者v持有的指针指向的值的Value封装，如果v的kind不是interface或者Ptr会报panic；如果v持有的值为nil，会返回Value零值。
       //Value封装即reflect.Value
       rVal = rVal.Elem()
       //绑定的方法直接调用，在这里要想用Set方法，必须是指针指向的值调用，即必须使用Elem后调用，reflect.Value是不能直接调用的。
       rVal.SetInt(20)
       //rV := rVal.Interface()
       //num := rV.(*int)
       //*num = 20
       //fmt.Println(*num)
   }
   
   func main() {
       num := 10
       reflect01(&num)
       fmt.Println(num)
   }
   ```
5. 