### 切片：

- **切片的定义：**

  1. 定义一个切片，然后让切片去引用一个已经创建好的数组。

     ```go
     //定义数组
     intarr := [...]int{1, 2, 4, 67, 5, 3}
     //定义切片
     var slice []int = intarr[1:3] //1，3为索引，包含左边不包含右边，即从索引1到索引2[1,3)
     ```

  2. make函数

     ```go
     //定义切片：make函数的三个参数：1.切片类型  2.切片长度  3.切片的容量
     //由make底层创建一个数组，对外不可见，所以不可以直接操作这个数组，要通过slices区间接的访问各个元素，不可以直接对数组进行维护/操作
     slices := make([]int, 4, 20)
     fmt.Println(slices)
     fmt.Println("切片的长度为：", len(slices))
     fmt.Println("切片的容量为：", cap(slices))
     ```

  3. 直接指定

     ```go
     //定义切片：直接指定具体数组，类似make方式，数组不可直接操作
     slice2 := []int{1, 4, 7}
     fmt.Println(slice2)
     fmt.Println("切片的长度为：", len(slice2))
     fmt.Println("切片的容量为：", cap(slice2))
     ```

- **切片的遍历：**

  1. 普通for循环

     ```go
     for i := 0; i < len(slice2); i++ {
         fmt.Printf("slice2[%d] = %v\t", i, slice2[i])
     }
     ```

  2. for range循环

     ```go
     //for range循环
     for key, value := range slice2 {
         fmt.Printf("slice2[%d] = %v\t", key, value)
     }
     ```

- **注意：**

  1. 切片不能只声明不引用数组

     ```go
     var slice []int
     fmt.Println(slice)
     //无法对切片进行访问，需引用数组
     ```

  2. 切片不能越界

  3. 切片的简写

     ***[0:end] = [:end]*** 

     ***[start:len(arr)] = [start:]***

     ***[0:len(arr)] = [:]***

  4. 切片还能再次切片

  5. 切片可以动态增长

     *切片只要长度len<底层数组容量cap就能覆盖追加*
  
     ```go
     //当切片长度 < 容量时：追加元素会直接覆盖底层数组的 “空闲位置”，长度增加 1，容量不变（无需新数组）；
     //当切片长度 == 容量时：底层数组已满，append 会创建一个 新的底层数组（容量通常是原容量的 2 倍，小切片初始扩容可能不同），将原数据复制到新数组，再追加元素，此时 长度增加 1，容量翻倍。
     //slice2底层数组指向的是一个新数组，而slice指向的旧数组仍未扩充
     slice2 := append(slice, 22, 32, 324)
     slice = append(slice, 22, 32, 324)
     fmt.Println(slice)
     fmt.Println(slice2)
     ```
  
     结果：![image-20250908092139764](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250908092139764.png)
  
  6. 可以通过append函数将切片追加给切片
  
     ```go
     slice3 := []int{1, 54, 5}
     slice = append(slice, slice3...)
     fmt.Println(slice)
     ```
  
     结果：![image-20250908092155904](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250908092155904.png)
  
  7. 切片的复制
  
     ```go
     //此时slice4改变值，slice2中的值并不改变，它俩底层是两个数组
     slice4 := make([]int, 10)
     copy(slice4, slice2)
     fmt.Println(slice4)
     ```



