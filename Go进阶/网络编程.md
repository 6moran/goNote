<img src="C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250927150759430.png" alt="image-20250927150759430"  />

**端口(port)：**

1. 0是保留端口

2. 1-1024是固定端口，又叫有名端口，即被某些程序固定使用，一般程序员不使用。

   例如：22：SSH远程登录协议  23：relnet使用  21：ftp使用

   ​			23：smtp服务使用  80：iis使用  7：echo服务

3. 1025-65535是动态端口，这些端口，程序员可以使用。



1. 服务器监听：

   ```go
   //1.tcp表示使用的网络协议是tcp
   //2.0.0.0.0:8888表示在本地监听8888端口
   //3.localhost和127.0.0.1都是仅允许本机访问，不能用IPv4地址访问
   listen, err := net.Listen("tcp", "0.0.0.0:8888")
   if err != nil {
   		fmt.Println("listen err=", err)
   		return
   }
   defer listen.Close() //延时关闭listen
   ```

2. 等待客户端链接：

   ```go
   for {
       //等待客户端来链接
       fmt.Println("等待客户端来链接...")
       //这里会阻塞等待，直到有客户端链接
       conn, er := listen.Accept()
       if er != nil {
          fmt.Println("Accept() err=", err)
       } else {
          fmt.Printf("Accept() suc con=%v 客户端ip=%v\n", conn, conn.RemoteAddr().String())
       }
   }
   ```

3. 客户端链接：

   ```go
   //这里192.168.21.10是本机的ipv4，8888是监听的端口
   conn, err := net.Dial("tcp", "192.168.21.10:8888")
   if err != nil {
   	fmt.Printf("client dial err=%v\n", err)
   	return
   }
   ```

4. 服务端和客户端之间的消息传输：

   ```go
   func process(conn net.Conn) {
       defer conn.Close()
       for {
          buf := make([]byte, 1024)
          //conn.Read(buf)，等待客户端通过conn发送数据
          //如果客户端没有write发送，那么协程就会阻塞在这里
          //fmt.Println("服务器在等待输入")
          //这里返回的n是该切片传输消数据的长度
          n, err := conn.Read(buf)
          if err != nil {
             fmt.Println("服务器的Read err=", err)
             return
          }
          //显示客户端发送的内容到服务器的终端
          fmt.Print(string(buf[:n]))
       }
   }
   
   //发送数据
   func WriteData(conn net.Conn, str string) error {
   	_, err := conn.Write([]byte(str))
   	if err != nil {
   		return err
   	}
   	return nil
   }
   ```

   当然也可以像文件那样操作（创建一个bufio读取器来读取）：

   ```go
   // 客户端和服务端之间的数据读取
   func ReadData(conn net.Conn) (string, error) {
       reader := bufio.NewReader(conn)
       str, err := reader.ReadString('\n')
       if err != nil {
          return "", err
       }
       return strings.Trim(str, "\r\n"), nil
   }
   ```





实例：

服务端：

```go
package main

import (
    "fmt"
    "net"
)

func process(conn net.Conn) {
    defer conn.Close()
    for {
       buf := make([]byte, 1024)
       //conn.Read(buf)，等待客户端通过conn发送信息
       //如果客户端没有write发送，那么协程就会阻塞在这里
       //fmt.Println("服务器在等待输入")
       n, err := conn.Read(buf)
       if err != nil {
          fmt.Println("服务器的Read err=", err)
          return
       }
       //显示客户端发送的内容到服务器的终端
       fmt.Print(string(buf[:n]))
    }
}

func main() {
    fmt.Println("服务器开始监听...")
    //1.tcp表示使用的网络协议是tcp
    //2.0.0.0.0:8888表示在本地监听8888端口
    //3.localhost和127.0.0.1都是仅允许本机访问，不能用IPv4地址访问
    listen, err := net.Listen("tcp", "0.0.0.0:8888")
    if err != nil {
       fmt.Println("listen err=", err)
       return
    }
    defer listen.Close() //延时关闭listen
    for {
       //等待客户端来链接
       fmt.Println("等待客户端来链接...")
       conn, er := listen.Accept()
       if er != nil {
          fmt.Println("Accept() err=", err)
       } else {
          fmt.Printf("Accept() suc con=%v 客户端ip=%v\n", conn, conn.RemoteAddr().String())
       }
       go process(conn)
       //这里写一个协程，为客户端服务
    }

    fmt.Printf("listen suc=%v\n", listen)

}
```

客户端：

```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
    "strings"
)

func main() {
    conn, err := net.Dial("tcp", "192.168.21.10:8888")
    if err != nil {
       fmt.Printf("client dial err=%v\n", err)
       return
    }
    fmt.Printf("conn=%v 成功\n", conn)
    reader := bufio.NewReader(os.Stdin)
    for {
       line, err := reader.ReadString('\n')
       if err != nil {
          fmt.Println("err=", err)
       }
       line = strings.Trim(line, "\r\n")
       if line == "exit" {
          fmt.Println("客户端退出了")
          break
       }
       n, er := conn.Write([]byte(line + "\n"))
       if er != nil {
          fmt.Println("err=", err)
       }       
       fmt.Println("客户端发送了数据", n)

    }

}
```