os.File封装所有关于文件的操作，File是一个结构体。

**文件操作：**

1. 打开文件用于读取，关闭文件，关闭失败会返回一个error

   ```go
   //打开一个文件
   //概念说明：file可以叫file对象，file指针，file文件句柄
   file, err := os.Open("d:/test.txt")
   if err != nil {
       fmt.Println(err)
   }
   fmt.Printf("file=%v", file)
   
   //关闭文件
   er := file.Close()
   if err != nil {
       fmt.Println(er)
   }
   ```

2. 读取文件内容并显示在终端。

   ```go
   reader := bufio.NewReader(file)
   for {
       str, err := reader.ReadString('\n') //读到一个换行就结束，换行也会读出来
       //io.EOF表示读取到文件末尾了
       if err == io.EOF {
          break
       }
       fmt.Print(str)
   }
   fmt.Println("文件读取结束")
   ```

   还可以使用`ioutil`方法一次性将整个文件读入到内存中，这种方式适用于**文件不大**的情况。相关方法和函数`（ioutil.ReadFile）`

   ```go
   func main() {
       //使用ioutil.ReadFile一次性奖文件读取到位
       file := "d:/test.txt"
       content, err := ioutil.ReadFile(file)
       if err != nil {
          fmt.Printf("%v", err)
       }
       fmt.Println(string(content))
   }
   ```

   该方法已经弃用了。
   
3. `OpenFile`方法。

   ```go
   func OpenFile(name string,flag int,perm FileMode)(file *File,err error)
   ```

   `OpenFile`三个参数分别是（文件的路径，打开模式，Linux文件权限）

   windows第三个参数不写

   打开模式有：

   ![image-20250919214932247](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250919214932247.png)

   可以组合使用，中间使用|

```go
func main() {
    filePath := "d:/test.txt"
    //os.O_WRONLY表示写入os.O_CREATE表示没有该文件就创建一个
    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
       fmt.Printf("open file err=%v", err)
       return
    }
	
    //及时关闭file句柄
    defer file.Close()

    str := "hello gardondad\n"
    writer := bufio.NewWriter(file)
    for i := 0; i < 5; i++ {
       writer.WriteString(str)
    }
    //writer是自带缓存的，因此在调用WriteString时，内容先写在换存的，如果不调用Flush方法，是无法真正写入的
    writer.Flush()
}
```

 4. 判断文件是否存在。

    ```go
    func Stat(name string) (fi FileInfo,err error)
    ```

    使用`os.Stat`函数，只用err判断即可

    ```go
    func PathExists(path string)(bool,error){
        _,err := os.Stat(path)
        if err == nil {
           return true,nil
        }
        if os.IsNotExist(err){		//这里使用os.IsNotExist()方法来判断返回的错误类型是否为文件不存在的错误
           return false,nil
        }
        //这里如果返回的错误是其他类型，则不确定是否存在
        return false,err
    }
    ```

 5. 移动光标

    ```go
    //第一个参数是偏移量，第二个参数是起始位置
    func (f *os.File) Seek(offset int64, whence int) (int64, error)
    ```

    移动到文件开头：`io.SeekStart`

    从当前位置移动：`io.SeekCurrent`

    从文件末尾移动：`io.SeekEnd`

    ```go
    _, er := file.Seek(0, io.SeekStart)
    if err != nil {
        fmt.Println("移动失败", er)
    }
    ```

 6. 创建文件夹：

    创建多级文件夹：

    ```go
    err := os.MkdirAll("D:/file/mn", 0755)
    if err != nil {
        fmt.Println(err)
    }
    ```

    创建单个文件夹：

    ```go
    err := os.Mkdir("D:/file", 0755)
    if err != nil {
        fmt.Println(err)
    }
    ```

    
