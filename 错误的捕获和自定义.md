**错误的捕获：**

错误：

```go
package main

import "fmt"

func main() {
    test()
    fmt.Println("上面的函数执行成功")
    fmt.Println("继续执行下面的语句")
}

func test() {
    num1 := 10
    num2 := 0
    result := num1 / num2
    fmt.Println(result)
}
```

结果：![image-20250907151735433](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250907151735433.png)

出现了一个错误（除数为0），后面的语句不再执行。



运用defer+recover捕获机制：

```go
func test() {
	defer func() {
		//recover内置函数可以捕获错误
		err := recover()
		//如果没有捕获错误，返回值则为零值：nil
		if err != nil {
			fmt.Println("出现错误，当前错误已捕获")
			fmt.Printf("err是：%v\n", err)
		}
	}() //最后要调用匿名函数，defer后面不能是表达式，需要是函数调用
	num1 := 10
	num2 := 0
	result := num1 / num2
	fmt.Println(result)
}
```

运行结果：![image-20250907152758776](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250907152758776.png)

`defer` 语句后面**必须跟函数或方法调用**，不能直接跟表达式（如算术运算、变量赋值等）

**原因：**`defer` 的设计目的是确保某些清理操作（如关闭文件、释放资源）在函数退出前执行，这些操作本质上都是 “函数行为”（如 `file.Close()`）。如果允许普通表达式，会违背 `defer` 用于 “延迟执行操作” 的设计初衷，还可能导致歧义（如赋值表达式的执行时机难以预期）。

------



**自定义错误：**

```go
func main() {
	err := test()
	fmt.Println(err)
	if err != nil {
		fmt.Println("自定义错误：", err)
	}
	fmt.Println("上面的函数执行成功")
	fmt.Println("继续执行下面的语句")
}

//返回一个error类型的错误
func test() error {
    num1 := 10
    num2 := 0
    if num2 == 0 {
       return errors.New("除数不能为0")	//New的作用将自定义的字符串转换为一个error类型的值进行返回
    } else {
       result := num1 / num2
       fmt.Println(result)
       //没有错误返回零值即可
       return nil
    }
}
```

执行结果：![image-20250907155731183](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250907155731183.png)

如果捕获错误后不想让程序继续进行就在后面加一个panic(err)

例如：

```go
if err != nil {
    fmt.Println("自定义错误：", err)
    panic(err)
}
```

执行结果：![image-20250907155911697](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250907155911697.png)

panic和error的区别：

![image-20250919210957746](C:\Users\16053\AppData\Roaming\Typora\typora-user-images\image-20250919210957746.png)

**`errors.Is` 和 `errors.As`：**

`errors.Is`：判断错误链中是否包含目标错误。

```go
var ErrNotFound = errors.New("not found")

func findItem(id int) error {
    //返回值为database error: not found
    return fmt.Errorf("database error: %w", ErrNotFound)
}

func main() {
    err := findItem(1)
    //errors.Is(err, ErrNotFound):  true
    if errors.Is(err, ErrNotFound) {
       fmt.Println("Item not found")
    } else {
       fmt.Println("Other error:", err)
    }
}
```

`errors.As`：从错误链中提取特定类型的错误。

```go
type MyError struct {
    Code int
    Msg  string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("Code: %d, Msg: %s", e.Code, e.Msg)
}

func getError() error {
    return &MyError{Code: 404, Msg: "Not Found"}
}

func main() {
    err := getError()
    fmt.Println(err)
    var myErr *MyError
    if errors.As(err, &myErr) {
       fmt.Printf("Custom error - Code: %d, Msg: %s\n", myErr.Code, myErr.Msg)
    }
}
```